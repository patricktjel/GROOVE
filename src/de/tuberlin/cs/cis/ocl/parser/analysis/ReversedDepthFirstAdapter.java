/* This file was generated by SableCC (http://www.sablecc.org/). */

package de.tuberlin.cs.cis.ocl.parser.analysis;

import java.util.*;
import de.tuberlin.cs.cis.ocl.parser.node.*;

public class ReversedDepthFirstAdapter extends AnalysisAdapter
{
    public void inStart(Start node)
    {
        defaultIn(node);
    }

    public void outStart(Start node)
    {
        defaultOut(node);
    }

    public void defaultIn(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    public void defaultOut(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    @Override
    public void caseStart(Start node)
    {
        inStart(node);
        node.getEOF().apply(this);
        node.getPOclFile().apply(this);
        outStart(node);
    }

    public void inAOclFile(AOclFile node)
    {
        defaultIn(node);
    }

    public void outAOclFile(AOclFile node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOclFile(AOclFile node)
    {
        inAOclFile(node);
        {
            List<PConstraint> copy = new ArrayList<PConstraint>(node.getConstraint());
            Collections.reverse(copy);
            for(PConstraint e : copy)
            {
                e.apply(this);
            }
        }
        outAOclFile(node);
    }

    public void inAConstraint(AConstraint node)
    {
        defaultIn(node);
    }

    public void outAConstraint(AConstraint node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAConstraint(AConstraint node)
    {
        inAConstraint(node);
        {
            List<PContextBodypart> copy = new ArrayList<PContextBodypart>(node.getContextBodypart());
            Collections.reverse(copy);
            for(PContextBodypart e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getContextDeclaration() != null)
        {
            node.getContextDeclaration().apply(this);
        }
        outAConstraint(node);
    }

    public void inADefinitionContextBodypart(ADefinitionContextBodypart node)
    {
        defaultIn(node);
    }

    public void outADefinitionContextBodypart(ADefinitionContextBodypart node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADefinitionContextBodypart(ADefinitionContextBodypart node)
    {
        inADefinitionContextBodypart(node);
        {
            List<PLetExpression> copy = new ArrayList<PLetExpression>(node.getLetExpression());
            Collections.reverse(copy);
            for(PLetExpression e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getColon() != null)
        {
            node.getColon().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getDef() != null)
        {
            node.getDef().apply(this);
        }
        outADefinitionContextBodypart(node);
    }

    public void inAConstraintContextBodypart(AConstraintContextBodypart node)
    {
        defaultIn(node);
    }

    public void outAConstraintContextBodypart(AConstraintContextBodypart node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAConstraintContextBodypart(AConstraintContextBodypart node)
    {
        inAConstraintContextBodypart(node);
        if(node.getOclExpression() != null)
        {
            node.getOclExpression().apply(this);
        }
        if(node.getColon() != null)
        {
            node.getColon().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getStereotype() != null)
        {
            node.getStereotype().apply(this);
        }
        outAConstraintContextBodypart(node);
    }

    public void inAContextDeclaration(AContextDeclaration node)
    {
        defaultIn(node);
    }

    public void outAContextDeclaration(AContextDeclaration node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAContextDeclaration(AContextDeclaration node)
    {
        inAContextDeclaration(node);
        if(node.getContextKind() != null)
        {
            node.getContextKind().apply(this);
        }
        if(node.getContext() != null)
        {
            node.getContext().apply(this);
        }
        outAContextDeclaration(node);
    }

    public void inAOperationContextKind(AOperationContextKind node)
    {
        defaultIn(node);
    }

    public void outAOperationContextKind(AOperationContextKind node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOperationContextKind(AOperationContextKind node)
    {
        inAOperationContextKind(node);
        if(node.getReturnType() != null)
        {
            node.getReturnType().apply(this);
        }
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        if(node.getFormalParameterList() != null)
        {
            node.getFormalParameterList().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        if(node.getContextOperationName() != null)
        {
            node.getContextOperationName().apply(this);
        }
        if(node.getDcolon() != null)
        {
            node.getDcolon().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAOperationContextKind(node);
    }

    public void inAClassifierContextKind(AClassifierContextKind node)
    {
        defaultIn(node);
    }

    public void outAClassifierContextKind(AClassifierContextKind node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAClassifierContextKind(AClassifierContextKind node)
    {
        inAClassifierContextKind(node);
        if(node.getClassifierType() != null)
        {
            node.getClassifierType().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAClassifierContextKind(node);
    }

    public void inAReturnType(AReturnType node)
    {
        defaultIn(node);
    }

    public void outAReturnType(AReturnType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReturnType(AReturnType node)
    {
        inAReturnType(node);
        if(node.getTypeSpecifier() != null)
        {
            node.getTypeSpecifier().apply(this);
        }
        if(node.getColon() != null)
        {
            node.getColon().apply(this);
        }
        outAReturnType(node);
    }

    public void inAClassifierType(AClassifierType node)
    {
        defaultIn(node);
    }

    public void outAClassifierType(AClassifierType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAClassifierType(AClassifierType node)
    {
        inAClassifierType(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getColon() != null)
        {
            node.getColon().apply(this);
        }
        outAClassifierType(node);
    }

    public void inAPreConditionStereotype(APreConditionStereotype node)
    {
        defaultIn(node);
    }

    public void outAPreConditionStereotype(APreConditionStereotype node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPreConditionStereotype(APreConditionStereotype node)
    {
        inAPreConditionStereotype(node);
        if(node.getPre() != null)
        {
            node.getPre().apply(this);
        }
        outAPreConditionStereotype(node);
    }

    public void inAPostConditionStereotype(APostConditionStereotype node)
    {
        defaultIn(node);
    }

    public void outAPostConditionStereotype(APostConditionStereotype node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPostConditionStereotype(APostConditionStereotype node)
    {
        inAPostConditionStereotype(node);
        if(node.getPost() != null)
        {
            node.getPost().apply(this);
        }
        outAPostConditionStereotype(node);
    }

    public void inAInvariantStereotype(AInvariantStereotype node)
    {
        defaultIn(node);
    }

    public void outAInvariantStereotype(AInvariantStereotype node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAInvariantStereotype(AInvariantStereotype node)
    {
        inAInvariantStereotype(node);
        if(node.getInv() != null)
        {
            node.getInv().apply(this);
        }
        outAInvariantStereotype(node);
    }

    public void inAContextOperationName(AContextOperationName node)
    {
        defaultIn(node);
    }

    public void outAContextOperationName(AContextOperationName node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAContextOperationName(AContextOperationName node)
    {
        inAContextOperationName(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAContextOperationName(node);
    }

    public void inALogicalContextOperationName(ALogicalContextOperationName node)
    {
        defaultIn(node);
    }

    public void outALogicalContextOperationName(ALogicalContextOperationName node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALogicalContextOperationName(ALogicalContextOperationName node)
    {
        inALogicalContextOperationName(node);
        if(node.getLogicalOperator() != null)
        {
            node.getLogicalOperator().apply(this);
        }
        outALogicalContextOperationName(node);
    }

    public void inARelationalContextOperationName(ARelationalContextOperationName node)
    {
        defaultIn(node);
    }

    public void outARelationalContextOperationName(ARelationalContextOperationName node)
    {
        defaultOut(node);
    }

    @Override
    public void caseARelationalContextOperationName(ARelationalContextOperationName node)
    {
        inARelationalContextOperationName(node);
        if(node.getRelationalOperator() != null)
        {
            node.getRelationalOperator().apply(this);
        }
        outARelationalContextOperationName(node);
    }

    public void inAAddContextOperationName(AAddContextOperationName node)
    {
        defaultIn(node);
    }

    public void outAAddContextOperationName(AAddContextOperationName node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAddContextOperationName(AAddContextOperationName node)
    {
        inAAddContextOperationName(node);
        if(node.getAddOperator() != null)
        {
            node.getAddOperator().apply(this);
        }
        outAAddContextOperationName(node);
    }

    public void inAMultiplyContextOperationName(AMultiplyContextOperationName node)
    {
        defaultIn(node);
    }

    public void outAMultiplyContextOperationName(AMultiplyContextOperationName node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMultiplyContextOperationName(AMultiplyContextOperationName node)
    {
        inAMultiplyContextOperationName(node);
        if(node.getMultiplyOperator() != null)
        {
            node.getMultiplyOperator().apply(this);
        }
        outAMultiplyContextOperationName(node);
    }

    public void inAFormalParameterList(AFormalParameterList node)
    {
        defaultIn(node);
    }

    public void outAFormalParameterList(AFormalParameterList node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFormalParameterList(AFormalParameterList node)
    {
        inAFormalParameterList(node);
        if(node.getParamList() != null)
        {
            node.getParamList().apply(this);
        }
        outAFormalParameterList(node);
    }

    public void inAParamList(AParamList node)
    {
        defaultIn(node);
    }

    public void outAParamList(AParamList node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParamList(AParamList node)
    {
        inAParamList(node);
        {
            List<PNextParam> copy = new ArrayList<PNextParam>(node.getNextParam());
            Collections.reverse(copy);
            for(PNextParam e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getFormalParameter() != null)
        {
            node.getFormalParameter().apply(this);
        }
        outAParamList(node);
    }

    public void inAFormalParameter(AFormalParameter node)
    {
        defaultIn(node);
    }

    public void outAFormalParameter(AFormalParameter node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFormalParameter(AFormalParameter node)
    {
        inAFormalParameter(node);
        if(node.getTypePostfix() != null)
        {
            node.getTypePostfix().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAFormalParameter(node);
    }

    public void inANextParam(ANextParam node)
    {
        defaultIn(node);
    }

    public void outANextParam(ANextParam node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANextParam(ANextParam node)
    {
        inANextParam(node);
        if(node.getFormalParameter() != null)
        {
            node.getFormalParameter().apply(this);
        }
        if(node.getComma() != null)
        {
            node.getComma().apply(this);
        }
        outANextParam(node);
    }

    public void inAOclExpression(AOclExpression node)
    {
        defaultIn(node);
    }

    public void outAOclExpression(AOclExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOclExpression(AOclExpression node)
    {
        inAOclExpression(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getLetDeclaration() != null)
        {
            node.getLetDeclaration().apply(this);
        }
        outAOclExpression(node);
    }

    public void inALetDeclaration(ALetDeclaration node)
    {
        defaultIn(node);
    }

    public void outALetDeclaration(ALetDeclaration node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALetDeclaration(ALetDeclaration node)
    {
        inALetDeclaration(node);
        if(node.getIn() != null)
        {
            node.getIn().apply(this);
        }
        {
            List<PLetExpression> copy = new ArrayList<PLetExpression>(node.getLetExpression());
            Collections.reverse(copy);
            for(PLetExpression e : copy)
            {
                e.apply(this);
            }
        }
        outALetDeclaration(node);
    }

    public void inALetExpression(ALetExpression node)
    {
        defaultIn(node);
    }

    public void outALetExpression(ALetExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALetExpression(ALetExpression node)
    {
        inALetExpression(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getEqual() != null)
        {
            node.getEqual().apply(this);
        }
        if(node.getTypePostfix() != null)
        {
            node.getTypePostfix().apply(this);
        }
        if(node.getLetParameterList() != null)
        {
            node.getLetParameterList().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getLet() != null)
        {
            node.getLet().apply(this);
        }
        outALetExpression(node);
    }

    public void inALetParameterList(ALetParameterList node)
    {
        defaultIn(node);
    }

    public void outALetParameterList(ALetParameterList node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALetParameterList(ALetParameterList node)
    {
        inALetParameterList(node);
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        if(node.getFormalParameterList() != null)
        {
            node.getFormalParameterList().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        outALetParameterList(node);
    }

    public void inATypePostfix(ATypePostfix node)
    {
        defaultIn(node);
    }

    public void outATypePostfix(ATypePostfix node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATypePostfix(ATypePostfix node)
    {
        inATypePostfix(node);
        if(node.getTypeSpecifier() != null)
        {
            node.getTypeSpecifier().apply(this);
        }
        if(node.getColon() != null)
        {
            node.getColon().apply(this);
        }
        outATypePostfix(node);
    }

    public void inAIfExpression(AIfExpression node)
    {
        defaultIn(node);
    }

    public void outAIfExpression(AIfExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIfExpression(AIfExpression node)
    {
        inAIfExpression(node);
        if(node.getEndif() != null)
        {
            node.getEndif().apply(this);
        }
        if(node.getElseBranch() != null)
        {
            node.getElseBranch().apply(this);
        }
        if(node.getElse() != null)
        {
            node.getElse().apply(this);
        }
        if(node.getThenBranch() != null)
        {
            node.getThenBranch().apply(this);
        }
        if(node.getThen() != null)
        {
            node.getThen().apply(this);
        }
        if(node.getCondition() != null)
        {
            node.getCondition().apply(this);
        }
        if(node.getIf() != null)
        {
            node.getIf().apply(this);
        }
        outAIfExpression(node);
    }

    public void inAExpression(AExpression node)
    {
        defaultIn(node);
    }

    public void outAExpression(AExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAExpression(AExpression node)
    {
        inAExpression(node);
        if(node.getLogicalExpression() != null)
        {
            node.getLogicalExpression().apply(this);
        }
        outAExpression(node);
    }

    public void inALogicalExpression(ALogicalExpression node)
    {
        defaultIn(node);
    }

    public void outALogicalExpression(ALogicalExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALogicalExpression(ALogicalExpression node)
    {
        inALogicalExpression(node);
        {
            List<PImplication> copy = new ArrayList<PImplication>(node.getImplication());
            Collections.reverse(copy);
            for(PImplication e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getBooleanExpression() != null)
        {
            node.getBooleanExpression().apply(this);
        }
        outALogicalExpression(node);
    }

    public void inAImplication(AImplication node)
    {
        defaultIn(node);
    }

    public void outAImplication(AImplication node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAImplication(AImplication node)
    {
        inAImplication(node);
        if(node.getBooleanExpression() != null)
        {
            node.getBooleanExpression().apply(this);
        }
        if(node.getImpliesOperator() != null)
        {
            node.getImpliesOperator().apply(this);
        }
        outAImplication(node);
    }

    public void inABooleanExpression(ABooleanExpression node)
    {
        defaultIn(node);
    }

    public void outABooleanExpression(ABooleanExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseABooleanExpression(ABooleanExpression node)
    {
        inABooleanExpression(node);
        {
            List<PBooleanOperation> copy = new ArrayList<PBooleanOperation>(node.getBooleanOperation());
            Collections.reverse(copy);
            for(PBooleanOperation e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getRelationalExpression() != null)
        {
            node.getRelationalExpression().apply(this);
        }
        outABooleanExpression(node);
    }

    public void inABooleanOperation(ABooleanOperation node)
    {
        defaultIn(node);
    }

    public void outABooleanOperation(ABooleanOperation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseABooleanOperation(ABooleanOperation node)
    {
        inABooleanOperation(node);
        if(node.getRelationalExpression() != null)
        {
            node.getRelationalExpression().apply(this);
        }
        if(node.getBooleanOperator() != null)
        {
            node.getBooleanOperator().apply(this);
        }
        outABooleanOperation(node);
    }

    public void inARelationalExpression(ARelationalExpression node)
    {
        defaultIn(node);
    }

    public void outARelationalExpression(ARelationalExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseARelationalExpression(ARelationalExpression node)
    {
        inARelationalExpression(node);
        if(node.getEquation() != null)
        {
            node.getEquation().apply(this);
        }
        if(node.getCompareableExpression() != null)
        {
            node.getCompareableExpression().apply(this);
        }
        outARelationalExpression(node);
    }

    public void inAEquation(AEquation node)
    {
        defaultIn(node);
    }

    public void outAEquation(AEquation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAEquation(AEquation node)
    {
        inAEquation(node);
        if(node.getCompareableExpression() != null)
        {
            node.getCompareableExpression().apply(this);
        }
        if(node.getEquationOperator() != null)
        {
            node.getEquationOperator().apply(this);
        }
        outAEquation(node);
    }

    public void inACompareableExpression(ACompareableExpression node)
    {
        defaultIn(node);
    }

    public void outACompareableExpression(ACompareableExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACompareableExpression(ACompareableExpression node)
    {
        inACompareableExpression(node);
        if(node.getComparison() != null)
        {
            node.getComparison().apply(this);
        }
        if(node.getAdditiveExpression() != null)
        {
            node.getAdditiveExpression().apply(this);
        }
        outACompareableExpression(node);
    }

    public void inAComparison(AComparison node)
    {
        defaultIn(node);
    }

    public void outAComparison(AComparison node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAComparison(AComparison node)
    {
        inAComparison(node);
        if(node.getAdditiveExpression() != null)
        {
            node.getAdditiveExpression().apply(this);
        }
        if(node.getCompareOperator() != null)
        {
            node.getCompareOperator().apply(this);
        }
        outAComparison(node);
    }

    public void inAAdditiveExpression(AAdditiveExpression node)
    {
        defaultIn(node);
    }

    public void outAAdditiveExpression(AAdditiveExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAdditiveExpression(AAdditiveExpression node)
    {
        inAAdditiveExpression(node);
        {
            List<PAddition> copy = new ArrayList<PAddition>(node.getAddition());
            Collections.reverse(copy);
            for(PAddition e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getMultiplicativeExpression() != null)
        {
            node.getMultiplicativeExpression().apply(this);
        }
        outAAdditiveExpression(node);
    }

    public void inAAddition(AAddition node)
    {
        defaultIn(node);
    }

    public void outAAddition(AAddition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAddition(AAddition node)
    {
        inAAddition(node);
        if(node.getMultiplicativeExpression() != null)
        {
            node.getMultiplicativeExpression().apply(this);
        }
        if(node.getAddOperator() != null)
        {
            node.getAddOperator().apply(this);
        }
        outAAddition(node);
    }

    public void inAMultiplicativeExpression(AMultiplicativeExpression node)
    {
        defaultIn(node);
    }

    public void outAMultiplicativeExpression(AMultiplicativeExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMultiplicativeExpression(AMultiplicativeExpression node)
    {
        inAMultiplicativeExpression(node);
        {
            List<PMultiplication> copy = new ArrayList<PMultiplication>(node.getMultiplication());
            Collections.reverse(copy);
            for(PMultiplication e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getUnaryExpression() != null)
        {
            node.getUnaryExpression().apply(this);
        }
        outAMultiplicativeExpression(node);
    }

    public void inAMultiplication(AMultiplication node)
    {
        defaultIn(node);
    }

    public void outAMultiplication(AMultiplication node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMultiplication(AMultiplication node)
    {
        inAMultiplication(node);
        if(node.getUnaryExpression() != null)
        {
            node.getUnaryExpression().apply(this);
        }
        if(node.getMultiplyOperator() != null)
        {
            node.getMultiplyOperator().apply(this);
        }
        outAMultiplication(node);
    }

    public void inAPrefixedUnaryExpression(APrefixedUnaryExpression node)
    {
        defaultIn(node);
    }

    public void outAPrefixedUnaryExpression(APrefixedUnaryExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPrefixedUnaryExpression(APrefixedUnaryExpression node)
    {
        inAPrefixedUnaryExpression(node);
        if(node.getPostfixExpression() != null)
        {
            node.getPostfixExpression().apply(this);
        }
        if(node.getUnaryOperator() != null)
        {
            node.getUnaryOperator().apply(this);
        }
        outAPrefixedUnaryExpression(node);
    }

    public void inAUnaryExpression(AUnaryExpression node)
    {
        defaultIn(node);
    }

    public void outAUnaryExpression(AUnaryExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAUnaryExpression(AUnaryExpression node)
    {
        inAUnaryExpression(node);
        if(node.getPostfixExpression() != null)
        {
            node.getPostfixExpression().apply(this);
        }
        outAUnaryExpression(node);
    }

    public void inAPostfixExpression(APostfixExpression node)
    {
        defaultIn(node);
    }

    public void outAPostfixExpression(APostfixExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPostfixExpression(APostfixExpression node)
    {
        inAPostfixExpression(node);
        {
            List<PPropertyInvocation> copy = new ArrayList<PPropertyInvocation>(node.getPropertyInvocation());
            Collections.reverse(copy);
            for(PPropertyInvocation e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getPrimaryExpression() != null)
        {
            node.getPrimaryExpression().apply(this);
        }
        outAPostfixExpression(node);
    }

    public void inAObjectPropertyInvocation(AObjectPropertyInvocation node)
    {
        defaultIn(node);
    }

    public void outAObjectPropertyInvocation(AObjectPropertyInvocation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAObjectPropertyInvocation(AObjectPropertyInvocation node)
    {
        inAObjectPropertyInvocation(node);
        if(node.getPropertyCall() != null)
        {
            node.getPropertyCall().apply(this);
        }
        if(node.getDot() != null)
        {
            node.getDot().apply(this);
        }
        outAObjectPropertyInvocation(node);
    }

    public void inACollectionPropertyInvocation(ACollectionPropertyInvocation node)
    {
        defaultIn(node);
    }

    public void outACollectionPropertyInvocation(ACollectionPropertyInvocation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACollectionPropertyInvocation(ACollectionPropertyInvocation node)
    {
        inACollectionPropertyInvocation(node);
        if(node.getPropertyCall() != null)
        {
            node.getPropertyCall().apply(this);
        }
        if(node.getArrow() != null)
        {
            node.getArrow().apply(this);
        }
        outACollectionPropertyInvocation(node);
    }

    public void inACollectionPrimaryExpression(ACollectionPrimaryExpression node)
    {
        defaultIn(node);
    }

    public void outACollectionPrimaryExpression(ACollectionPrimaryExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACollectionPrimaryExpression(ACollectionPrimaryExpression node)
    {
        inACollectionPrimaryExpression(node);
        if(node.getLiteralCollection() != null)
        {
            node.getLiteralCollection().apply(this);
        }
        outACollectionPrimaryExpression(node);
    }

    public void inALiteralPrimaryExpression(ALiteralPrimaryExpression node)
    {
        defaultIn(node);
    }

    public void outALiteralPrimaryExpression(ALiteralPrimaryExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALiteralPrimaryExpression(ALiteralPrimaryExpression node)
    {
        inALiteralPrimaryExpression(node);
        if(node.getLiteral() != null)
        {
            node.getLiteral().apply(this);
        }
        outALiteralPrimaryExpression(node);
    }

    public void inAPropertyCallPrimaryExpression(APropertyCallPrimaryExpression node)
    {
        defaultIn(node);
    }

    public void outAPropertyCallPrimaryExpression(APropertyCallPrimaryExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPropertyCallPrimaryExpression(APropertyCallPrimaryExpression node)
    {
        inAPropertyCallPrimaryExpression(node);
        if(node.getPropertyCall() != null)
        {
            node.getPropertyCall().apply(this);
        }
        outAPropertyCallPrimaryExpression(node);
    }

    public void inAParenthesedPrimaryExpression(AParenthesedPrimaryExpression node)
    {
        defaultIn(node);
    }

    public void outAParenthesedPrimaryExpression(AParenthesedPrimaryExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParenthesedPrimaryExpression(AParenthesedPrimaryExpression node)
    {
        inAParenthesedPrimaryExpression(node);
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        outAParenthesedPrimaryExpression(node);
    }

    public void inAIfPrimaryExpression(AIfPrimaryExpression node)
    {
        defaultIn(node);
    }

    public void outAIfPrimaryExpression(AIfPrimaryExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIfPrimaryExpression(AIfPrimaryExpression node)
    {
        inAIfPrimaryExpression(node);
        if(node.getIfExpression() != null)
        {
            node.getIfExpression().apply(this);
        }
        outAIfPrimaryExpression(node);
    }

    public void inATimeExpression(ATimeExpression node)
    {
        defaultIn(node);
    }

    public void outATimeExpression(ATimeExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATimeExpression(ATimeExpression node)
    {
        inATimeExpression(node);
        if(node.getPre() != null)
        {
            node.getPre().apply(this);
        }
        if(node.getAt() != null)
        {
            node.getAt().apply(this);
        }
        outATimeExpression(node);
    }

    public void inAPropertyCall(APropertyCall node)
    {
        defaultIn(node);
    }

    public void outAPropertyCall(APropertyCall node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPropertyCall(APropertyCall node)
    {
        inAPropertyCall(node);
        if(node.getPropertyCallParameters() != null)
        {
            node.getPropertyCallParameters().apply(this);
        }
        if(node.getQualifiers() != null)
        {
            node.getQualifiers().apply(this);
        }
        if(node.getTimeExpression() != null)
        {
            node.getTimeExpression().apply(this);
        }
        if(node.getPathName() != null)
        {
            node.getPathName().apply(this);
        }
        outAPropertyCall(node);
    }

    public void inAPropertyCallParameters(APropertyCallParameters node)
    {
        defaultIn(node);
    }

    public void outAPropertyCallParameters(APropertyCallParameters node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPropertyCallParameters(APropertyCallParameters node)
    {
        inAPropertyCallParameters(node);
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        if(node.getActualParameterList() != null)
        {
            node.getActualParameterList().apply(this);
        }
        if(node.getDeclarator() != null)
        {
            node.getDeclarator().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        outAPropertyCallParameters(node);
    }

    public void inAActualParameterList(AActualParameterList node)
    {
        defaultIn(node);
    }

    public void outAActualParameterList(AActualParameterList node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAActualParameterList(AActualParameterList node)
    {
        inAActualParameterList(node);
        {
            List<PNextExpr> copy = new ArrayList<PNextExpr>(node.getNextExpr());
            Collections.reverse(copy);
            for(PNextExpr e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        outAActualParameterList(node);
    }

    public void inANextExpr(ANextExpr node)
    {
        defaultIn(node);
    }

    public void outANextExpr(ANextExpr node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANextExpr(ANextExpr node)
    {
        inANextExpr(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getComma() != null)
        {
            node.getComma().apply(this);
        }
        outANextExpr(node);
    }

    public void inAConcreteDeclarator(AConcreteDeclarator node)
    {
        defaultIn(node);
    }

    public void outAConcreteDeclarator(AConcreteDeclarator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAConcreteDeclarator(AConcreteDeclarator node)
    {
        inAConcreteDeclarator(node);
        if(node.getBar() != null)
        {
            node.getBar().apply(this);
        }
        if(node.getAccumulator() != null)
        {
            node.getAccumulator().apply(this);
        }
        if(node.getSimpleTypePostfix() != null)
        {
            node.getSimpleTypePostfix().apply(this);
        }
        if(node.getActualParameterList() != null)
        {
            node.getActualParameterList().apply(this);
        }
        outAConcreteDeclarator(node);
    }

    public void inAAccumulator(AAccumulator node)
    {
        defaultIn(node);
    }

    public void outAAccumulator(AAccumulator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAccumulator(AAccumulator node)
    {
        inAAccumulator(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getEqual() != null)
        {
            node.getEqual().apply(this);
        }
        if(node.getTypeSpecifier() != null)
        {
            node.getTypeSpecifier().apply(this);
        }
        if(node.getColon() != null)
        {
            node.getColon().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getSemicolon() != null)
        {
            node.getSemicolon().apply(this);
        }
        outAAccumulator(node);
    }

    public void inANameList(ANameList node)
    {
        defaultIn(node);
    }

    public void outANameList(ANameList node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANameList(ANameList node)
    {
        inANameList(node);
        {
            List<PNextName> copy = new ArrayList<PNextName>(node.getNextName());
            Collections.reverse(copy);
            for(PNextName e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outANameList(node);
    }

    public void inANextName(ANextName node)
    {
        defaultIn(node);
    }

    public void outANextName(ANextName node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANextName(ANextName node)
    {
        inANextName(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getComma() != null)
        {
            node.getComma().apply(this);
        }
        outANextName(node);
    }

    public void inASimpleTypePostfix(ASimpleTypePostfix node)
    {
        defaultIn(node);
    }

    public void outASimpleTypePostfix(ASimpleTypePostfix node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASimpleTypePostfix(ASimpleTypePostfix node)
    {
        inASimpleTypePostfix(node);
        if(node.getSimpleTypeSpecifier() != null)
        {
            node.getSimpleTypeSpecifier().apply(this);
        }
        if(node.getColon() != null)
        {
            node.getColon().apply(this);
        }
        outASimpleTypePostfix(node);
    }

    public void inAQualifiers(AQualifiers node)
    {
        defaultIn(node);
    }

    public void outAQualifiers(AQualifiers node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAQualifiers(AQualifiers node)
    {
        inAQualifiers(node);
        if(node.getRBracket() != null)
        {
            node.getRBracket().apply(this);
        }
        if(node.getActualParameterList() != null)
        {
            node.getActualParameterList().apply(this);
        }
        if(node.getLBracket() != null)
        {
            node.getLBracket().apply(this);
        }
        outAQualifiers(node);
    }

    public void inALogicalOperator(ALogicalOperator node)
    {
        defaultIn(node);
    }

    public void outALogicalOperator(ALogicalOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALogicalOperator(ALogicalOperator node)
    {
        inALogicalOperator(node);
        if(node.getBooleanOperator() != null)
        {
            node.getBooleanOperator().apply(this);
        }
        outALogicalOperator(node);
    }

    public void inAImplicativeLogicalOperator(AImplicativeLogicalOperator node)
    {
        defaultIn(node);
    }

    public void outAImplicativeLogicalOperator(AImplicativeLogicalOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAImplicativeLogicalOperator(AImplicativeLogicalOperator node)
    {
        inAImplicativeLogicalOperator(node);
        if(node.getImpliesOperator() != null)
        {
            node.getImpliesOperator().apply(this);
        }
        outAImplicativeLogicalOperator(node);
    }

    public void inAAndBooleanOperator(AAndBooleanOperator node)
    {
        defaultIn(node);
    }

    public void outAAndBooleanOperator(AAndBooleanOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAndBooleanOperator(AAndBooleanOperator node)
    {
        inAAndBooleanOperator(node);
        if(node.getAnd() != null)
        {
            node.getAnd().apply(this);
        }
        outAAndBooleanOperator(node);
    }

    public void inAOrBooleanOperator(AOrBooleanOperator node)
    {
        defaultIn(node);
    }

    public void outAOrBooleanOperator(AOrBooleanOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOrBooleanOperator(AOrBooleanOperator node)
    {
        inAOrBooleanOperator(node);
        if(node.getOr() != null)
        {
            node.getOr().apply(this);
        }
        outAOrBooleanOperator(node);
    }

    public void inAXorBooleanOperator(AXorBooleanOperator node)
    {
        defaultIn(node);
    }

    public void outAXorBooleanOperator(AXorBooleanOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAXorBooleanOperator(AXorBooleanOperator node)
    {
        inAXorBooleanOperator(node);
        if(node.getXor() != null)
        {
            node.getXor().apply(this);
        }
        outAXorBooleanOperator(node);
    }

    public void inAImpliesOperator(AImpliesOperator node)
    {
        defaultIn(node);
    }

    public void outAImpliesOperator(AImpliesOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAImpliesOperator(AImpliesOperator node)
    {
        inAImpliesOperator(node);
        if(node.getImplies() != null)
        {
            node.getImplies().apply(this);
        }
        outAImpliesOperator(node);
    }

    public void inAEqualityRelationalOperator(AEqualityRelationalOperator node)
    {
        defaultIn(node);
    }

    public void outAEqualityRelationalOperator(AEqualityRelationalOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAEqualityRelationalOperator(AEqualityRelationalOperator node)
    {
        inAEqualityRelationalOperator(node);
        if(node.getEquationOperator() != null)
        {
            node.getEquationOperator().apply(this);
        }
        outAEqualityRelationalOperator(node);
    }

    public void inACompareRelationalOperator(ACompareRelationalOperator node)
    {
        defaultIn(node);
    }

    public void outACompareRelationalOperator(ACompareRelationalOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACompareRelationalOperator(ACompareRelationalOperator node)
    {
        inACompareRelationalOperator(node);
        if(node.getCompareOperator() != null)
        {
            node.getCompareOperator().apply(this);
        }
        outACompareRelationalOperator(node);
    }

    public void inAEquationOperator(AEquationOperator node)
    {
        defaultIn(node);
    }

    public void outAEquationOperator(AEquationOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAEquationOperator(AEquationOperator node)
    {
        inAEquationOperator(node);
        if(node.getEqual() != null)
        {
            node.getEqual().apply(this);
        }
        outAEquationOperator(node);
    }

    public void inAInEquationOperator(AInEquationOperator node)
    {
        defaultIn(node);
    }

    public void outAInEquationOperator(AInEquationOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAInEquationOperator(AInEquationOperator node)
    {
        inAInEquationOperator(node);
        if(node.getNEqual() != null)
        {
            node.getNEqual().apply(this);
        }
        outAInEquationOperator(node);
    }

    public void inAGtCompareOperator(AGtCompareOperator node)
    {
        defaultIn(node);
    }

    public void outAGtCompareOperator(AGtCompareOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAGtCompareOperator(AGtCompareOperator node)
    {
        inAGtCompareOperator(node);
        if(node.getGt() != null)
        {
            node.getGt().apply(this);
        }
        outAGtCompareOperator(node);
    }

    public void inALtCompareOperator(ALtCompareOperator node)
    {
        defaultIn(node);
    }

    public void outALtCompareOperator(ALtCompareOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALtCompareOperator(ALtCompareOperator node)
    {
        inALtCompareOperator(node);
        if(node.getLt() != null)
        {
            node.getLt().apply(this);
        }
        outALtCompareOperator(node);
    }

    public void inAGteqCompareOperator(AGteqCompareOperator node)
    {
        defaultIn(node);
    }

    public void outAGteqCompareOperator(AGteqCompareOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAGteqCompareOperator(AGteqCompareOperator node)
    {
        inAGteqCompareOperator(node);
        if(node.getGteq() != null)
        {
            node.getGteq().apply(this);
        }
        outAGteqCompareOperator(node);
    }

    public void inALteqCompareOperator(ALteqCompareOperator node)
    {
        defaultIn(node);
    }

    public void outALteqCompareOperator(ALteqCompareOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALteqCompareOperator(ALteqCompareOperator node)
    {
        inALteqCompareOperator(node);
        if(node.getLteq() != null)
        {
            node.getLteq().apply(this);
        }
        outALteqCompareOperator(node);
    }

    public void inAPlusAddOperator(APlusAddOperator node)
    {
        defaultIn(node);
    }

    public void outAPlusAddOperator(APlusAddOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPlusAddOperator(APlusAddOperator node)
    {
        inAPlusAddOperator(node);
        if(node.getPlus() != null)
        {
            node.getPlus().apply(this);
        }
        outAPlusAddOperator(node);
    }

    public void inAMinusAddOperator(AMinusAddOperator node)
    {
        defaultIn(node);
    }

    public void outAMinusAddOperator(AMinusAddOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMinusAddOperator(AMinusAddOperator node)
    {
        inAMinusAddOperator(node);
        if(node.getMinus() != null)
        {
            node.getMinus().apply(this);
        }
        outAMinusAddOperator(node);
    }

    public void inAMultMultiplyOperator(AMultMultiplyOperator node)
    {
        defaultIn(node);
    }

    public void outAMultMultiplyOperator(AMultMultiplyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMultMultiplyOperator(AMultMultiplyOperator node)
    {
        inAMultMultiplyOperator(node);
        if(node.getMult() != null)
        {
            node.getMult().apply(this);
        }
        outAMultMultiplyOperator(node);
    }

    public void inADivMultiplyOperator(ADivMultiplyOperator node)
    {
        defaultIn(node);
    }

    public void outADivMultiplyOperator(ADivMultiplyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADivMultiplyOperator(ADivMultiplyOperator node)
    {
        inADivMultiplyOperator(node);
        if(node.getDiv() != null)
        {
            node.getDiv().apply(this);
        }
        outADivMultiplyOperator(node);
    }

    public void inAMinusUnaryOperator(AMinusUnaryOperator node)
    {
        defaultIn(node);
    }

    public void outAMinusUnaryOperator(AMinusUnaryOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMinusUnaryOperator(AMinusUnaryOperator node)
    {
        inAMinusUnaryOperator(node);
        if(node.getMinus() != null)
        {
            node.getMinus().apply(this);
        }
        outAMinusUnaryOperator(node);
    }

    public void inANotUnaryOperator(ANotUnaryOperator node)
    {
        defaultIn(node);
    }

    public void outANotUnaryOperator(ANotUnaryOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANotUnaryOperator(ANotUnaryOperator node)
    {
        inANotUnaryOperator(node);
        if(node.getNot() != null)
        {
            node.getNot().apply(this);
        }
        outANotUnaryOperator(node);
    }

    public void inAOclAnyTypeSpecifier(AOclAnyTypeSpecifier node)
    {
        defaultIn(node);
    }

    public void outAOclAnyTypeSpecifier(AOclAnyTypeSpecifier node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOclAnyTypeSpecifier(AOclAnyTypeSpecifier node)
    {
        inAOclAnyTypeSpecifier(node);
        if(node.getSimpleTypeSpecifier() != null)
        {
            node.getSimpleTypeSpecifier().apply(this);
        }
        outAOclAnyTypeSpecifier(node);
    }

    public void inACollectionTypeSpecifier(ACollectionTypeSpecifier node)
    {
        defaultIn(node);
    }

    public void outACollectionTypeSpecifier(ACollectionTypeSpecifier node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACollectionTypeSpecifier(ACollectionTypeSpecifier node)
    {
        inACollectionTypeSpecifier(node);
        if(node.getCollectionType() != null)
        {
            node.getCollectionType().apply(this);
        }
        outACollectionTypeSpecifier(node);
    }

    public void inASimpleTypeSpecifier(ASimpleTypeSpecifier node)
    {
        defaultIn(node);
    }

    public void outASimpleTypeSpecifier(ASimpleTypeSpecifier node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASimpleTypeSpecifier(ASimpleTypeSpecifier node)
    {
        inASimpleTypeSpecifier(node);
        if(node.getPathName() != null)
        {
            node.getPathName().apply(this);
        }
        outASimpleTypeSpecifier(node);
    }

    public void inACollectionType(ACollectionType node)
    {
        defaultIn(node);
    }

    public void outACollectionType(ACollectionType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACollectionType(ACollectionType node)
    {
        inACollectionType(node);
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        if(node.getSimpleTypeSpecifier() != null)
        {
            node.getSimpleTypeSpecifier().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        if(node.getCollectionKind() != null)
        {
            node.getCollectionKind().apply(this);
        }
        outACollectionType(node);
    }

    public void inASetCollectionKind(ASetCollectionKind node)
    {
        defaultIn(node);
    }

    public void outASetCollectionKind(ASetCollectionKind node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASetCollectionKind(ASetCollectionKind node)
    {
        inASetCollectionKind(node);
        if(node.getSet() != null)
        {
            node.getSet().apply(this);
        }
        outASetCollectionKind(node);
    }

    public void inABagCollectionKind(ABagCollectionKind node)
    {
        defaultIn(node);
    }

    public void outABagCollectionKind(ABagCollectionKind node)
    {
        defaultOut(node);
    }

    @Override
    public void caseABagCollectionKind(ABagCollectionKind node)
    {
        inABagCollectionKind(node);
        if(node.getBag() != null)
        {
            node.getBag().apply(this);
        }
        outABagCollectionKind(node);
    }

    public void inASequenceCollectionKind(ASequenceCollectionKind node)
    {
        defaultIn(node);
    }

    public void outASequenceCollectionKind(ASequenceCollectionKind node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASequenceCollectionKind(ASequenceCollectionKind node)
    {
        inASequenceCollectionKind(node);
        if(node.getSequence() != null)
        {
            node.getSequence().apply(this);
        }
        outASequenceCollectionKind(node);
    }

    public void inACollectionKind(ACollectionKind node)
    {
        defaultIn(node);
    }

    public void outACollectionKind(ACollectionKind node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACollectionKind(ACollectionKind node)
    {
        inACollectionKind(node);
        if(node.getCollection() != null)
        {
            node.getCollection().apply(this);
        }
        outACollectionKind(node);
    }

    public void inALiteralCollection(ALiteralCollection node)
    {
        defaultIn(node);
    }

    public void outALiteralCollection(ALiteralCollection node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALiteralCollection(ALiteralCollection node)
    {
        inALiteralCollection(node);
        if(node.getRBrace() != null)
        {
            node.getRBrace().apply(this);
        }
        if(node.getCollectionItemList() != null)
        {
            node.getCollectionItemList().apply(this);
        }
        if(node.getLBrace() != null)
        {
            node.getLBrace().apply(this);
        }
        if(node.getCollectionKind() != null)
        {
            node.getCollectionKind().apply(this);
        }
        outALiteralCollection(node);
    }

    public void inACollectionItemList(ACollectionItemList node)
    {
        defaultIn(node);
    }

    public void outACollectionItemList(ACollectionItemList node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACollectionItemList(ACollectionItemList node)
    {
        inACollectionItemList(node);
        {
            List<PNextCollectionItem> copy = new ArrayList<PNextCollectionItem>(node.getNextCollectionItem());
            Collections.reverse(copy);
            for(PNextCollectionItem e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getCollectionItem() != null)
        {
            node.getCollectionItem().apply(this);
        }
        outACollectionItemList(node);
    }

    public void inANextCollectionItem(ANextCollectionItem node)
    {
        defaultIn(node);
    }

    public void outANextCollectionItem(ANextCollectionItem node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANextCollectionItem(ANextCollectionItem node)
    {
        inANextCollectionItem(node);
        if(node.getCollectionItem() != null)
        {
            node.getCollectionItem().apply(this);
        }
        if(node.getComma() != null)
        {
            node.getComma().apply(this);
        }
        outANextCollectionItem(node);
    }

    public void inACollectionItem(ACollectionItem node)
    {
        defaultIn(node);
    }

    public void outACollectionItem(ACollectionItem node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACollectionItem(ACollectionItem node)
    {
        inACollectionItem(node);
        if(node.getRange() != null)
        {
            node.getRange().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        outACollectionItem(node);
    }

    public void inARange(ARange node)
    {
        defaultIn(node);
    }

    public void outARange(ARange node)
    {
        defaultOut(node);
    }

    @Override
    public void caseARange(ARange node)
    {
        inARange(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getDdot() != null)
        {
            node.getDdot().apply(this);
        }
        outARange(node);
    }

    public void inAStringLiteral(AStringLiteral node)
    {
        defaultIn(node);
    }

    public void outAStringLiteral(AStringLiteral node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAStringLiteral(AStringLiteral node)
    {
        inAStringLiteral(node);
        if(node.getStringLiteral() != null)
        {
            node.getStringLiteral().apply(this);
        }
        outAStringLiteral(node);
    }

    public void inANumberLiteral(ANumberLiteral node)
    {
        defaultIn(node);
    }

    public void outANumberLiteral(ANumberLiteral node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANumberLiteral(ANumberLiteral node)
    {
        inANumberLiteral(node);
        if(node.getNumberLiteral() != null)
        {
            node.getNumberLiteral().apply(this);
        }
        outANumberLiteral(node);
    }

    public void inABooleanLiteral(ABooleanLiteral node)
    {
        defaultIn(node);
    }

    public void outABooleanLiteral(ABooleanLiteral node)
    {
        defaultOut(node);
    }

    @Override
    public void caseABooleanLiteral(ABooleanLiteral node)
    {
        inABooleanLiteral(node);
        if(node.getBooleanLiteral() != null)
        {
            node.getBooleanLiteral().apply(this);
        }
        outABooleanLiteral(node);
    }

    public void inAName(AName node)
    {
        defaultIn(node);
    }

    public void outAName(AName node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAName(AName node)
    {
        inAName(node);
        if(node.getIdentifier() != null)
        {
            node.getIdentifier().apply(this);
        }
        outAName(node);
    }

    public void inAPathName(APathName node)
    {
        defaultIn(node);
    }

    public void outAPathName(APathName node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPathName(APathName node)
    {
        inAPathName(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        {
            List<PNameQualifier> copy = new ArrayList<PNameQualifier>(node.getNameQualifier());
            Collections.reverse(copy);
            for(PNameQualifier e : copy)
            {
                e.apply(this);
            }
        }
        outAPathName(node);
    }

    public void inANameQualifier(ANameQualifier node)
    {
        defaultIn(node);
    }

    public void outANameQualifier(ANameQualifier node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANameQualifier(ANameQualifier node)
    {
        inANameQualifier(node);
        if(node.getDcolon() != null)
        {
            node.getDcolon().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outANameQualifier(node);
    }
}
